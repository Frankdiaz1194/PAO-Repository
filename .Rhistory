counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print
N <- 100000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print
N <- 100000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print
N <- 100000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 100000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
N <- 10000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
N <- 10000000000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
N <- 1000000000
# Initialize counter to count the number of samples between -1 and 1
counter <- 0
# Loop to generate random numbers from a standard normal distribution
# and count how many fall between -1 and 1
for (i in rnorm(N)) {
# Check if the current random number falls between -1 and 1
if (i >= -1 && i <= 1) {
# Increment the counter if the condition is met
counter <- counter + 1
}
}
# Calculate the proportion of samples between -1 and 1
answer <- counter / N
answer  # Print the proportion
gc()
Vic<- 3 45 56 700 32
#Vectors lesson
Vic<- c( 3, 45, 56, 700, 32)
is.numeric(Vic)
is.integer(Vic)
is.double(Vic)
v2,- c(1l,3L,4L,5L)
v2,- c(1L,3L,4L,5L)
v2<- c(1,3L,4L,5L)
v2<- c(1L,3L,4L,5L)
is.integer(v2
)
v3<- c("a","B23", "hello")
is.character(v3
)
is.numeric(v3)
v3<- c(7,"a","B23", "hello")
is.character(v3
)
is.numeric(v3)
seq(1,10)
1;10
1:10
seq(1,10,2)
y<-seq(1,10,5)
y
seq(1,100,2)
seq(2,100,2)
seq(2,100,.5)
rep(.33,100)
rep("w")
rep("w",10)
rep("v2",15)
rep(v2,15)
rep(v3,50)
getwd()
# GL NAV DOMESTIC INTERCONNECTIVITY MAPS
# FAST FACTS AND TALKING POINTS
# Last Updated: FEB 23, 2024
# CONTENTS:
# INPUT FILES NEEDED
# RECENT UPDATES TO CODE
# VARIABLES TO UPDATE MANUALLY AND ANNUALLY
# MAIN CODE
# ---
# INPUT FILES NEEDED ####
# IN SOURCE FILE LOCATION/ FOLDER
# ... GL Talking Points template spreadsheet
# ... national rankings spreadsheet from WCSC: save as WCSC_tonnagebystate_CY##.xlsx
# ... national cargo and trips spreadsheet (All Regions) from IWR/WCSC: save as Cargo_20##-20## All Regions 10yrs.xlsx
# IMPORTANT: you must save these files using very specific file names, to feed them through this R code
# WHERE TO GET NATIONAL RANKINGS
# . The national rankings spreadsheet is generated by WCSC every year, and is accessible through:
# ... WCSC Website > Commerce Data > Ports and States Data (Available in Excel format here) >
# ... select relevant calendar year
# ... Object title: Waterborne Commerce Statistics Center: CY 20## waterborne tonnage by state
# ... Download xlsx file, SAVE WITH THIS NAMING CONVENTION -- WCSC_tonnagebystate_CY##.xlsx
# ... Several tabs, e.g., Port_by_Tons
# ... Columns: RANK, PORT_NAME
# WHERE TO GET CARGO AND TRIPS DATA
# . This is a very large file with several 100,000s of rows of data.
# ... WCSC Website > Commerce Data > Waterborne Cargo and Trips Data Files >
# ... Select link with naming convention: Cargo_20##-20## All Regions 10yrs
# ... download xlsx file and use same naming convention
# ... Columns: Waterway, WaterwayName, TrafficCode, TrafficName, Commodity, etc.
# ---
# RECENT UPDATES TO CODE ####
# FY23
# ... FY22 talking points and fast facts highlighted shipment/receipt/thru/intraport data for ONE CY YEAR ONLY.
# ... FY23 talking points and fast facts highlight shipment/receipt/thru/intraport data for 5 YEAR AVERAGE.
# ... minor changes: FY23 file naming convention and set working directory
# ---
# UPDATE MANUALLY ####
# Set working directory every time you run file
# ... Navigation bar > Session > Set Working Directory > To Source File Location
# Manually update FY every year
FY <- 2023
# SEARCH FOR "UPDATE IN FY2024"
# ---
# MAIN BODY OF CODE ####
calendar_year <- FY-2
FY_short <- FY-2000
calendar_short <- calendar_year-2000
library(readxl)
library(openxlsx)
library(tidyr)
library(dplyr)
library(stringr)
# GL NAV DOMESTIC INTERCONNECTIVITY MAPS
# FAST FACTS AND TALKING POINTS
# Last Updated: MARCH 12, 2024
# INPUT FILES NEEDED ####
# IN SOURCE FILE LOCATION/ FOLDER
# ... GL Talking Points template spreadsheet
# ... national rankings spreadsheet from WCSC: save as WCSC_tonnagebystate_CY##.xlsx
# ... national cargo and trips spreadsheet (All Regions) from IWR/WCSC: save as Cargo_20##-20## All Regions 10yrs.xlsx
# IMPORTANT: you must save these files using very specific file names, to feed them through this R code
# WHERE TO GET NATIONAL RANKINGS
#  The national rankings spreadsheet is generated by WCSC every year, and is accessible through:
# ... WCSC Website > Commerce Data > Ports and States Data (Available in Excel format here) >
# ... select relevant calendar year
# ... Object title: Waterborne Commerce Statistics Center: CY 20## waterborne tonnage by state
# ... Download xlsx file, SAVE WITH THIS NAMING CONVENTION -- WCSC_tonnagebystate_CY##.xlsx
# ... Several tabs, e.g., Port_by_Tons
# ... Columns: RANK, PORT_NAME
# WHERE TO GET CARGO AND TRIPS DATA
#  This is a very large file with several 100,000s of rows of data.
# ... WCSC Website > Commerce Data > Waterborne Cargo and Trips Data Files >
# ... Select link with naming convention: Cargo_20##-20## All Regions 10yrs
# ... download xlsx file and use same naming convention
# ... Columns: Waterway, WaterwayName, TrafficCode, TrafficName, Commodity, etc.
# ---
# RECENT UPDATES TO CODE ####
# FY23
# ... FY22 talking points and fast facts highlighted shipment/receipt/thru/intraport data for ONE CY YEAR ONLY.
# ... FY23 talking points and fast facts highlight shipment/receipt/thru/intraport data for 5 YEAR AVERAGE.
# ... minor changes: FY23 file naming convention and set working directory
# FY24
# ... FY24  a looooooot of stuff
# ---
# UPDATE MANUALLY ####
# Set the project directory. Note: Inputs folder contains all raw data needed to run this code "Inputs/..."
setwd("C:/Users/h5pmldfb/OneDrive - US Army Corps of Engineers/PAO Project")
# Manually update FY every year
FY <- 2023
# Manually exclude ports for later calculate_ranking Function (Filter by )
Excluded_ports <- c(3001, 3101, 3191, 3201, 3230, 3301, 3401, 3501, 3601, 3701, 3802, 3810, 3811, 3850, 3901, 3999)
# SEARCH FOR "UPDATE IN FY2024"
# ---
# MAIN BODY OF CODE ####
# Calculate calendar year based on fiscal year
calendar_year <- FY - 2
# Calculate short version of fiscal year (e.g., FY23)
FY_short <- FY - 2000
# Calculate short version of calendar year (e.g., 23)
calendar_short <- calendar_year - 2000
# Load necessary libraries. Install packages if not done yet 'install.packages("my_package")'
library(readxl)
library(openxlsx)
library(tidyr)
library(dplyr)
library(stringr)
library(writexl)
library(purrr)
# Function to read tonnage and direction data for all ports nationally. File "Cargo2012-2021 All Regions"
read_tonnage_data <- function(calendar_year) {
# Construct the file path based on the calendar year
file_path <- paste0("Inputs/Cargo", calendar_year - 9, "-", calendar_year, " All Regions.xlsx")
# Check if the file exists
if (file.exists(file_path)) {
# Read the Excel file
data <- read_xlsx(file_path)
return(data)  # Return the data frame
} else {
stop("File not found:", file_path)  # Throw an error if the file is not found
}
}
#Store the result in the 'data' dataset/frame by calling the above function.
data <- read_tonnage_data(calendar_year)
# Run this lines to View the excluded ports
View_Excluded_ports <- data %>%
dplyr::filter(WaterwayCode %in% Excluded_ports) %>%
select(WaterwayCode, WaterwayName)%>%
distinct(WaterwayCode, .keep_all = TRUE)
View(View_Excluded_ports)
# Function to read harbor data and filter out specific harbors . File "Cargo2012-2021 All Regions"
read_harbor_data <- function() {
file_path <- "Inputs/GL_Talking_Points_CY21.xlsx"
if (file.exists(file_path)) {
# Read the Excel file and filter specific harbors
harbors <- read_xlsx(file_path, sheet = "Harbors") %>%
dplyr::filter(Harbor != "Indiana (Northern District), IN" & Harbor != "Buffington, IN")
# Correct spelling mistake in harbor name
harbors$Harbor[harbors$Harbor == "Detour, MI"] <- "DeTour, MI"
return(harbors)  # Return the filtered harbor data
} else {
stop("File not found:", file_path)  # Throw an error if the file is not found
}
}
#Store the result in the 'harbors' dataset/frame by calling the above function.
harbors <- read_harbor_data()
# Function to read national rankings for top 150 ports. File "WCSC_tonnagebystate_CY21"
read_national_rankings <- function(filename, sheet_name) {
tryCatch({
# Read file
national_rankings <- read_xlsx(filename, sheet = sheet_name)
# Remove empty rows and set correct column names
national_rankings <- national_rankings %>% slice(4:n())
colnames(national_rankings) <- national_rankings[1,]
national_rankings <- national_rankings[-1,]
return(national_rankings)
}, error = function(e) {
print(paste("Error reading file:", e$message))
# Return NULL or an empty data frame to indicate failure
return(NULL)
})
}
#Store the result in the 'national_rankings' dataset/frame by calling the above function.
national_rankings <- read_national_rankings("Inputs/WCSC_tonnagebystate_CY21.xlsx", "Port_by_Name")
# Function to create the rankings and add to carry on data
calculate_ranking <-function(data, year, exclude_codes) {
# Filter tonnage and direction data for GL data. Look only at most recent 5 years
gl_data <- data %>%
dplyr::filter((CompletedYear > year - 5 & CompletedYear <= year) & (WaterwayCode < 4000 & WaterwayCode > 3000))
# Replace NA values in WaterwayName with empty strings
gl_data$WaterwayName[is.na(gl_data$WaterwayName)] <- ""
# Calculate ranking of WaterwayName based on total tons (tons), sharing the same rank for tied values
gl_ranking <- gl_data %>%
#Filter data based on conditions, excluding ports specified by their codes.
filter(
CompletedYear == year &
!(WaterwayCode %in% exclude_codes)
) %>%
# Group data by WaterwayName
group_by(WaterwayName) %>%
# Calculate total tons for each WaterwayName
summarize(tons = sum(ShortTons)) %>%
# Arrange data in descending order of total tons
arrange(desc(tons)) %>%
# Add a new column 'rank' with the rank of each WaterwayName based on total tons
mutate(rank = dense_rank(desc(tons))) %>%
rename(WaterwayName_Ranked = WaterwayName,
tons_Ranked = tons,
rank = rank)
# Add NA values to gl_ranking to match the number of rows in gl_data while keeping the data manipulation within a single matrix.
gl_ranking_full <- bind_rows(gl_ranking, data.frame(WaterwayName_Ranked = rep("", nrow(gl_data) - nrow(gl_ranking)),#rep("" creates empty instead of NA
tons_Ranked = rep(NA, nrow(gl_data) - nrow(gl_ranking)),
rank = rep(NA, nrow(gl_data) - nrow(gl_ranking))))
# Add ranking information to gl_data as 3 new vectors
gl_data <- cbind(gl_data, gl_ranking_full)
return(gl_data)
}
#Store the result in the 'gl_data' dataset/frame by calling the above function.
gl_data <- calculate_ranking(data, calendar_year, Excluded_ports)
# Function to read ReconsRED data from an Excel file and manipulate it for fastfacts
read_ReconsRED <- function(filename, sheet_name) {
tryCatch({
# Read file
ReconsRED <- read_xlsx(filename, sheet = sheet_name)
# Rename columns
colnames(ReconsRED) <- c("Port_Name", "Tonnage_CY2021", "Direct", "Indirect_Induced", "Business_Revenue", "Labor_Income")
# Calculate total_jobs
ReconsRED <- ReconsRED %>%
mutate(total_jobs = Direct + Indirect_Induced)
# Round up total_jobs
ReconsRED$total_jobs <- ceiling(ReconsRED$total_jobs)
# Function to convert to million format
convert_to_million <- function(x) {
# Check if x is numeric
if (is.numeric(x)) {
# Round to one decimal place
x <- round(x, 1)
# If x is greater than or equal to 1 million
if (x >= 1e6) {
# Convert to million format
return(paste0(format(round(x / 1e6, 1), nsmall = 1)))
} else {
# Otherwise, return original value
return(as.character(x))
}
} else {
return(as.character(x))
}
}
# Apply function to Labor_Income and Business_Revenue columns
ReconsRED$Labor_Income <- sapply(ReconsRED$Labor_Income, convert_to_million)
ReconsRED$Business_Revenue <- sapply(ReconsRED$Business_Revenue, convert_to_million)
# Return manipulated dataset
return(ReconsRED)
}, error = function(e) {
# Handle error
print(paste("Error reading file:", e$message))
# Return NULL or an empty data frame to indicate failure
return(NULL)
})
}
# Store the result in the 'ReconsRED' dataset/frame by calling the above function
ReconsRED <- read_ReconsRED("Inputs/RECONS_RED_Contribution_(FY24_CY2021).xlsx", "Sheet1RAW")
View(ReconsRED)
